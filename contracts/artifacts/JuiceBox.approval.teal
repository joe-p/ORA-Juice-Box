#pragma version 9

// This TEAL was generated by TEALScript v0.67.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

abi_route_createApplication:
	// asa: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// app: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute createApplication(asset,application)void
	callsub createApplication
	int 1
	return

// createApplication(asset,application)void
createApplication:
	proto 2 0

	// contracts/juice_box.algo.ts:51
	// this.orangeApp.value = app
	byte 0x6f72616e6765417070 // "orangeApp"
	frame_dig -1 // app: Application
	app_global_put

	// contracts/juice_box.algo.ts:52
	// this.orangeAsa.value = asa
	byte 0x6f72616e6765417361 // "orangeAsa"
	frame_dig -2 // asa: Asset
	app_global_put
	retsub

abi_route_optIntoORA:
	// execute optIntoORA()void
	callsub optIntoORA
	int 1
	return

// optIntoORA()void
optIntoORA:
	proto 0 0

	// contracts/juice_box.algo.ts:56
	// sendAssetTransfer({
	//       xferAsset: this.orangeAsa.value,
	//       assetAmount: 0,
	//       assetReceiver: this.app.address,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/juice_box.algo.ts:57
	// xferAsset: this.orangeAsa.value
	byte 0x6f72616e6765417361 // "orangeAsa"
	app_global_get
	itxn_field XferAsset

	// contracts/juice_box.algo.ts:58
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts/juice_box.algo.ts:59
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

abi_route_mine:
	// _oraApp: application
	txna ApplicationArgs 2
	btoi
	txnas Applications

	// to: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// mbrAndFeePayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute mine(application,address,pay)void
	callsub mine
	int 1
	return

// mine(application,address,pay)void
//
// Mine ORA
//
// @param mbrAndFeePayment Payment to this app that covers the juice fee and any necessary MBRs
// @param to The address to mine on behalf of
// @param _oraApp ORA application (for reference)
mine:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/juice_box.algo.ts:76
	// verifyPayTxn(mbrAndFeePayment, { receiver: this.app.address })
	// verify receiver
	frame_dig -1 // mbrAndFeePayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/juice_box.algo.ts:78
	// juicer: JuicerID = {
	//       epoch: this.epoch.value,
	//       address: to,
	//     }
	frame_dig -2 // to: Address
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	concat
	frame_bury 0 // juicer: JuicerID

	// contracts/juice_box.algo.ts:83
	// juiceAmount = mbrAndFeePayment.amount
	frame_dig -1 // mbrAndFeePayment: PayTxn
	gtxns Amount
	frame_bury 1 // juiceAmount: uint64

	// if0_condition
	// contracts/juice_box.algo.ts:85
	// !this.juicers(juicer).exists
	frame_dig 0 // juicer: JuicerID
	box_len
	swap
	pop
	!
	bz if0_end

	// if0_consequent
	// contracts/juice_box.algo.ts:86
	// preMBR = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	assert
	frame_bury 2 // preMBR: uint64

	// contracts/juice_box.algo.ts:87
	// this.juicers(juicer).value = { juiced: 0, claimed: false }
	frame_dig 0 // juicer: JuicerID
	byte 0x0000000000000000
	byte 0x00
	int 0
	dup
	setbit
	box_put

	// contracts/juice_box.algo.ts:88
	// juiceAmount = juiceAmount - (this.app.address.minBalance - preMBR)
	frame_dig 1 // juiceAmount: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	assert
	frame_dig 2 // preMBR: uint64
	-
	-
	frame_bury 1 // juiceAmount: uint64

if0_end:
	// if1_condition
	// contracts/juice_box.algo.ts:91
	// !this.epochs(this.epoch.value).exists
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	box_len
	swap
	pop
	!
	bz if1_end

	// if1_consequent
	// contracts/juice_box.algo.ts:92
	// preMBR = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	assert
	frame_bury 3 // preMBR: uint64

	// contracts/juice_box.algo.ts:93
	// this.epochs(this.epoch.value).value = {
	//         start: globals.round,
	//         end: 0,
	//         totalJuiced: 0,
	//         mined: 0,
	//       }
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	global Round
	itob
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	box_put

	// contracts/juice_box.algo.ts:99
	// juiceAmount = juiceAmount - (this.app.address.minBalance - preMBR)
	frame_dig 1 // juiceAmount: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	assert
	frame_dig 3 // preMBR: uint64
	-
	-
	frame_bury 1 // juiceAmount: uint64

if1_end:
	// contracts/juice_box.algo.ts:102
	// sendMethodCall<[Address], void>({
	//       name: 'mine',
	//       applicationID: this.orangeApp.value,
	//       methodArgs: [this.app.address],
	//       fee: juiceAmount,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "mine(address)void"
	itxn_field ApplicationArgs

	// contracts/juice_box.algo.ts:104
	// applicationID: this.orangeApp.value
	byte 0x6f72616e6765417070 // "orangeApp"
	app_global_get
	itxn_field ApplicationID

	// contracts/juice_box.algo.ts:105
	// methodArgs: [this.app.address]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts/juice_box.algo.ts:106
	// fee: juiceAmount
	frame_dig 1 // juiceAmount: uint64
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/juice_box.algo.ts:111
	// this.juicers(juicer).value.juiced += mbrAndFeePayment.amount
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig 0 // juicer: JuicerID
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // mbrAndFeePayment: PayTxn
	gtxns Amount
	+
	itob
	frame_dig 0 // juicer: JuicerID
	cover 2
	box_replace

	// contracts/juice_box.algo.ts:112
	// this.epochs(this.epoch.value).value.totalJuiced += mbrAndFeePayment.amount
	int 16
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	box_get
	assert
	extract 16 8
	btoi
	frame_dig -1 // mbrAndFeePayment: PayTxn
	gtxns Amount
	+
	itob
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	cover 2
	box_replace
	retsub

// endEpoch()void
//
// End the current epoch
endEpoch:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/juice_box.algo.ts:119
	// oraMined = this.totalOra.value - this.app.address.assetBalance(this.orangeAsa.value)
	byte 0x746f74616c4f7261 // "totalOra"
	app_global_get
	global CurrentApplicationAddress
	byte 0x6f72616e6765417361 // "orangeAsa"
	app_global_get
	asset_holding_get AssetBalance
	assert
	-
	frame_bury 0 // oraMined: uint64

	// contracts/juice_box.algo.ts:120
	// assert(oraMined)
	frame_dig 0 // oraMined: uint64
	assert

	// contracts/juice_box.algo.ts:122
	// this.epochs(this.epoch.value).value.end = globals.round
	int 8
	global Round
	itob
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	cover 2
	box_replace

	// contracts/juice_box.algo.ts:123
	// this.epochs(this.epoch.value).value.mined = oraMined
	int 24
	frame_dig 0 // oraMined: uint64
	itob
	byte 0x65706f6368 // "epoch"
	app_global_get
	itob
	cover 2
	box_replace

	// contracts/juice_box.algo.ts:124
	// this.totalOra.value += oraMined
	byte 0x746f74616c4f7261 // "totalOra"
	app_global_get
	frame_dig 0 // oraMined: uint64
	+
	byte 0x746f74616c4f7261 // "totalOra"
	swap
	app_global_put

	// contracts/juice_box.algo.ts:125
	// this.epoch.value += 1
	byte 0x65706f6368 // "epoch"
	app_global_get
	int 1
	+
	byte 0x65706f6368 // "epoch"
	swap
	app_global_put
	retsub

abi_route_claim:
	// _ora: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// epoch: uint64
	txna ApplicationArgs 1
	btoi

	// execute claim(asset,address,uint64)void
	callsub claim
	int 1
	return

// claim(asset,address,uint64)void
//
// Claim ORA proportional to the amount juiced in the given epoch
// @param epoch The epoch to claim from
// @param to The address to send the ORA to
// @param _ora The ORA asset ID (for reference)
claim:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/juice_box.algo.ts:140
	// juicer: JuicerID = {
	//       epoch: epoch,
	//       address: to,
	//     }
	frame_dig -2 // to: Address
	frame_dig -1 // epoch: number
	itob
	concat
	frame_bury 0 // juicer: JuicerID

	// if2_condition
	// contracts/juice_box.algo.ts:145
	// this.epochs(epoch).value.end === 0
	frame_dig -1 // epoch: number
	itob
	box_get
	assert
	extract 8 8
	btoi
	int 0
	==
	bz if2_end

	// if2_consequent
	// contracts/juice_box.algo.ts:145
	// this.endEpoch()
	callsub endEpoch

if2_end:
	// contracts/juice_box.algo.ts:148
	// assert(!this.juicers(juicer).value.claimed)
	frame_dig 0 // juicer: JuicerID
	box_get
	assert
	store 255 // full array
	load 255 // full array
	int 65
	getbit
	!
	assert

	// contracts/juice_box.algo.ts:150
	// juicerInfo = this.juicers(juicer).value
	frame_dig 0 // juicer: JuicerID
	frame_bury 1 // storage key//juicerInfo

	// contracts/juice_box.algo.ts:151
	// epochInfo = this.epochs(epoch).value
	frame_dig -1 // epoch: number
	itob
	frame_bury 2 // storage key//epochInfo

	// contracts/juice_box.algo.ts:153
	// amount = (juicerInfo.juiced / epochInfo.totalJuiced) * epochInfo.mined
	frame_dig 1 // storage key//juicerInfo
	box_get
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig 2 // storage key//epochInfo
	box_get
	assert
	extract 16 8
	btoi
	/
	frame_dig 2 // storage key//epochInfo
	box_get
	assert
	extract 24 8
	btoi
	*
	frame_bury 3 // amount: uint64

	// contracts/juice_box.algo.ts:155
	// this.juicers(juicer).value.claimed = true
	store 255 // full array
	load 255 // full array
	int 65
	int 1
	setbit
	frame_dig 0 // juicer: JuicerID
	cover 2
	box_replace

	// contracts/juice_box.algo.ts:157
	// sendAssetTransfer({
	//       xferAsset: this.orangeAsa.value,
	//       assetAmount: amount,
	//       assetReceiver: to,
	//     })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/juice_box.algo.ts:158
	// xferAsset: this.orangeAsa.value
	byte 0x6f72616e6765417361 // "orangeAsa"
	app_global_get
	itxn_field XferAsset

	// contracts/juice_box.algo.ts:159
	// assetAmount: amount
	frame_dig 3 // amount: uint64
	itxn_field AssetAmount

	// contracts/juice_box.algo.ts:160
	// assetReceiver: to
	frame_dig -2 // to: Address
	itxn_field AssetReceiver

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

create_NoOp:
	method "createApplication(application,asset)void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "optIntoORA()void"
	method "mine(pay,address,application)void"
	method "claim(uint64,address,asset)void"
	txna ApplicationArgs 0
	match abi_route_optIntoORA abi_route_mine abi_route_claim
	err